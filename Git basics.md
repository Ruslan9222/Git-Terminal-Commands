# Git

## Установка Git

```
$ git version

/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

$ brew install git

```

## Настройка Git

```
$ git config --global user.name "User Namovich" # имя или ник нужно написать латиницей и в кавычках

$ git config --global user.email username@yandex.ru # здесь нужно указать свой настоящий email

$ cat ~/.gitconfig

$ git config --list

```

## Сделать папку репозиторием — git init

```
$ cd ~/dev/first-project # перешли в нужную папку

$ git init # создали репозиторий

```

## «Разгитить» папку, если что-то пошло не так, — rm -rf .git

```
$ cd <папка с репозиторием> # перешли в папку

$ rm -rf .git # удалили подпапку .git

```

## Подготовить файлы к сохранению — git add

```
$ touch todo.txt

$ touch readme.txt # создали файлы todo.txt и readme.txt

$ git status # проверили статус

$ git add --all # подготовили к сохранению все файлы в репозитории

$ git status # проверили статус

$ git add . # добавить всю текущую папку

$ git status

```

## Выполнить коммит — git commit

```
$ git commit -m 'Мой первый коммит!'

$ git log

$ git log --oneline # краткая информация  

```

# GitHub

## Проверка наличия SSH-ключа

```
$ cd ~ # перешли в домашнюю директорию

$ ls -la .ssh/ # вывели список созданных ключей

```

## Инструкция по генерации SSH-ключа

```
$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"

> Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи
> Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]

$ ls -a ~/.ssh

```

## Инструкция по связыванию SSH-ключа и GitHub-аккаунта

```
# скопировать содержимое ключа в буфер обмена:

$ pbcopy < ~/.ssh/id_rsa.pub

# для ed25519:

$ pbcopy < ~/.ssh/id_ed25519.pub

```

_Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта._

_В меню слева нажмите на пункт SSH and GPG keys._

_В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»)._

_В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»)._

_В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»)._

_В поле Key скопируйте ваш ключ из буфера обмена._

_Нажмите на кнопку Add SSH key (англ. «добавить SSH-ключ»)._



```
$ ssh -T git@github.com # Проверьте правильность ключа с помощью следующей команды.

```

## Привязать удалённый репозиторий к локальному — git remote add

```
$ cd ~/dev/first-project

$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git

```

## Убедиться, что репозитории связаны, — git remote -v

```
$ git remote -v

origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)

```

## Отправить изменения на удалённый репозиторий — git push

```
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте 
                          # заменить main на master.

$ git push

```


## Файл README.md

### Заголовки разных уровней создают решётками.

# H1 — заголовок первого уровня, самый большой
## H2 — заголовок второго уровня, поменьше
### H3
#### H4
##### H5
###### H6 — заголовок шестого уровня, самый маленький

```
# H1 — заголовок первого уровня, самый большой
## H2 — заголовок второго уровня, поменьше
### H3
#### H4
##### H5
###### H6 — заголовок шестого уровня, самый маленький

#### Заголовок 4

```


### Можно добавить черту под заголовком или абзацем.

Текст над чертой

---

Текст под чертой

```
Текст над чертой

---

Текст под чертой

```


### Чтобы сделать разрыв строки, нужно поставить два пробела (в примере ниже они обозначены точками ⋅⋅) или сочетание символов <br>.


Текст до переноса⋅⋅  
Текст после переноса <br>
Текст после второго переноса

```
Текст до переноса⋅⋅  
Текст после переноса <br>
Текст после второго переноса

```

### Чтобы начать новый параграф, в конце предыдущей строки должно стоять два символа переноса. Для этого нужно нажать Enter два раза.

line

another line  


```
line

another line  

```

## Выделение текста

### Чтобы выделить текст курсивом (*текст*), его заключают в звёздочки (астериски) или нижние подчёркивания.

Курсив — это *звёздочки* или _подчёркивания_. 

```
Курсив — это *звёздочки* или _подчёркивания_. 

```

### Чтобы выделить текст полужирным шрифтом (**текст**), его окружают двойными звёздочками или двойными нижними подчёркиваниями.

Полужирный шрифт — двойные **звёздочки** или двойные __подчёркивания__.

Можно совместить выделение **звёздочки и _подчёркивания_**. 

```
Полужирный шрифт — двойные **звёздочки** или двойные __подчёркивания__.

Можно совместить выделение **звёздочки и _подчёркивания_**. 

```

### Чтобы зачеркнуть текст (~~текст~~), его окружают двойными волнистыми линиями — тильдами.

~~Зачёркнутый текст.~~

```
~~Зачёркнутый текст.~~

```

## Списки

### Для оформления нумерованного списка достаточно поставить в начало строки цифры с точкой.

1. Первый пункт нумерованного списка.

2. Второй пункт.

```
1. Первый пункт нумерованного списка.

2. Второй пункт.

```

### Ненумерованный список создаётся звёздочкой с пробелом в начале строки либо дефисом с пробелом.

* первый пункт ненумерованного списка;

* второй пункт ненумерованного списка


- первый пункт ненумерованного списка;

- второй пункт ненумерованного списка 

```
* первый пункт ненумерованного списка;
* второй пункт ненумерованного списка

- первый пункт ненумерованного списка;
- второй пункт ненумерованного списка 

```

## Ссылки

### Чтобы сделать ссылкой часть текста, его заключают в квадратные скобки, а затем указывают нужный адрес в круглых скобках.

[Яндекс](https://www.yandex.ru) 

```
[Яндекс](https://www.yandex.ru) 

```

### Также можно добавить ссылке тайтл (от англ title — «название», «заголовок»). Тайтл — это всплывающая подсказка, которая появляется при наведении мыши на ссылку. Тайтл нужно заключить в кавычки и указать внутри скобок после адреса.

[Яндекс](https://www.yandex.ru "Я Yandex!") 

```
[Яндекс](https://www.yandex.ru "Я Yandex!") 

```

## Код

### Чтобы оформить текст как код, нужно окружить его тройками косых кавычек — грависов. После первой тройки грависов указывают язык программирования, на котором написан код. В маркдауне есть поддержка синтаксиса почти всех популярных языков и инструментов.

```bash
ls - la
```
```html
<h1>А я просто текст</h1>
``` 

## Пример файла README.md

# Шпаргалка markdown

## Выделение текста

Вы можете выделять текст в markdown с помощью символов `_` или `*`. Например:

Пример _курсива_ и **жирного** текста.

## Заголовки

Заголовки можно создавать с помощью символа `#`. Чем больше `#`, тем меньше заголовок. Например:

# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня

## Выделение кода

Чтобы выделить текст как код, поместите его в тройные кавычки `````. 

```
mkdir my_project
cd my_project
git init
```
Это лишь некоторые функции markdown. 

## GitHub-стиль

_GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта._

_Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё._ 

_Для этого в любом месте сообщения нужно указать #<номер задачи>. Например, вот так._


```
$ git commit -m "Исправить #334, добавить график температуры"

```

# Исследуем лог

## Элементы описания коммита

```
$ git log

```

[результат выполнения команды](https://pictures.s3.yandex.net/resources/M2_T5_02_1685969923.png)

## Получить сокращённый лог — git log --oneline

```
$ git log --oneline

```

[результат выполнения команды](https://pictures.s3.yandex.net/resources/M2_T5_03_1685970110.png)


# HEAD — всему голова

[взгляни на HEAD](https://pictures.s3.yandex.net/resources/M2_T5_01_1685972979.png)

## Файл HEAD

```
$ pwd # посмотрели, где мы /Users/user/dev/first-project

$ cd .git/

$ ls # посмотрели, какие есть файлы

COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
HEAD            config     hooks/       info/  objects/

$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/master # в файле вот такая ссылка

```

_Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки)._

_Если заглянуть в этот файл, можно увидеть хеш последнего коммита._


```
$ cat refs/heads/master # взяли ссылку из файла HEAD внутри хеш e007f5035f113f9abca78fe2149c593959da5eb7

$ git log # сверяем с хешем последнего коммита commit e007f5035f113f9abca78fe2149c593959da5eb7

Author: John Doe <johndoe@example.com>

Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел

... # другие коммиты

```

_Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита._

_Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master._

_При работе с Git указатель HEAD используется довольно часто._ 

_Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита._

_Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит._


# Статусы файлов в Git

## Статусы untracked/tracked, staged и modified


* **untracked (англ. «неотслеживаемый»)**
 
_Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые._

_Git «видит», что такой файл существует, но не следит за изменениями в нём._

_У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add._


* **staged (англ. «подготовленный»)**

_После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит._

_В этот момент файл находится в состоянии staged._


* **tracked (англ. «отслеживаемый»)**

_Состояние tracked — это противоположность untracked._

_Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add._

_То есть все файлы, в которых Git так или иначе отслеживает изменения._


* **modified (англ. «изменённый»)**

_Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия._

_Например, файл был закоммичен и после этого изменён._


## Про staged и modified

_Команда git add добавляет в staging area только текущее содержимое файла._

_Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging._

_Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging._

_Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз._


## Типичный жизненный цикл файла в Git

[жизненный цикл файла](https://pictures.s3.yandex.net/resources/M2_T5_1686651284.png)

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.

2. Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked). 

	* Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked). _Обратите внимание: staged и modified у одного файла, но у разных его версий._

	* Ещё раз выполнили git add. Состояние: staged (+ tracked).

3. Сделали коммит с помощью git commit. Состояние: tracked.

4. Изменили файл. Состояние: modified (+ tracked).

5. Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).

6. Сделали коммит. Состояния: tracked.

7. Повторили пункты 4−7 много-много раз.


# Как читать git status


## Какие состояния показывает git status

В итоге git status показывает только следующие состояния файлов:

* **staged** _(Changes to be committed в выводе git status);_

* **modified** _(Changes not staged for commit);_

* **untracked** _(Untracked files)._

## Подготавливаем репозиторий

Чтобы попрактиковаться, инициализируйте новый репозиторий ~/dev/git-status-lesson. 

Создайте в нём файл README.md и закоммитьте его.


```
$ cd ~/dev

$ mkdir git-status-lesson

$ cd git-status-lesson

$ git init # тут Git выведет что-нибудь, но мы это пропустим

$ touch README.md

$ git add README.md

$ git commit -m 'Добавить README' # по традиции первым создадим и закоммитим файл README.md

```

## Типичные варианты вывода git status

Рассмотрим четыре примера состояний, в которых может находиться ваш репозиторий.

### Нет ни staged-, ни modified-, ни untracked-файлов.

Если ничего не менять в git-status-lesson после первого коммита, то в нём не должно быть ни изменённых файлов (modified), ни новых (untracked), ни добавленных в список на коммит (staged). 

Вызовите команду git status. Её вывод будет примерно таким.

```
$ git status

On branch master
nothing to commit, working tree clean 

```
Это означает, что в репозитории нет новых или изменённых файлов. 

Последняя строка nothing to commit, working tree clean буквально переводится как «нечего коммитить, рабочая директория чиста».

Первая строка On branch master сообщает, что текущая ветка — master.


### Найдены неотслеживаемые файлы.

Создайте в папке ~/dev/git-status-lesson файл fileA.txt.

Теперь в репозитории есть новый файл в состоянии untracked. 

Снова вызовите команду git status. Результат будет таким.


```
$ touch fileA.txt

$ git status

On branch master
Untracked files: # найдены неотслеживаемые файлы
  (use "git add <file>..." to include in what will be committed)
        fileA.txt

nothing added to commit but untracked files present (use "git add" to track)

```
Файл fileA.txt отображается в секции неотслеживаемых файлов — Untracked files. Это значит, что он не был добавлен в репозиторий через git add.

Добавьте fileA.txt в staging area с помощью git add и снова запросите git status.

```
$ git add fileA.txt 

$ git status

On branch master
Changes to be committed: # новая секция
  (use "git restore --staged <file>..." to unstage)
        new file:   fileA.txt

```
В этот раз git status подсказывает, что существует команда git restore. 

Мы познакомим вас с ней в одном из будущих уроков.



Теперь fileA.txt находится в секции Changes to be committed (англ. «изменения, которые попадут в коммит»). Если сейчас выполнить коммит, то в репозитории будет зафиксирована текущая версия этого файла. Закоммитьте его.

```
$ git commit -m 'Добавить файл fileA.txt' # тут будет вывод комманды commit, он нас не интересует

$ git status

On branch master
nothing to commit, working tree clean

```
Вывод команды git status такой же, какой был после первого коммита: «Директория чиста».

### Найдены изменения, которые не войдут в коммит

Теперь откройте файл fileA.txt и добавьте в него несколько слов — например, Это файл A!. 

Сохраните fileA.txt и вызовите команду git status. 

Её результат будет такой.

```
# внесли в fileA.txt правки # запросили статус

$ git status 

On branch master
Changes not staged for commit: # ещё одна секция
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   fileA.txt

```
Файл fileA.txt был изменён, но ещё не добавлен в staging area после этого. 

Так он оказался в секции Changes not staged for commit (англ. «изменения, которые не подготовлены к коммиту»). Эта секция соответствует статусу modified.

Подготовьте правки к коммиту с помощью git add.

```
$ git add fileA.txt

$ git status

On branch master
Changes to be committed: # все изменения готовы к коммиту
  (use "git restore --staged <file>..." to unstage)
        modified:   fileA.txt

```

Теперь в коммит попадёт уже новая версия файла fileA.txt.

💡 Обратите внимание: хотя вывод команды git status очень похож на тот, который был после первого добавления файла fileA.txt, они всё же отличаются.

Когда совсем новый файл попадает в staging area, перед его названием указывается new file. Вот так: new file: fileA.txt.

Если файл уже однажды попадал в историю (с помощью коммита) и был изменён, после выполнения git add он будет записан уже так: modified: fileA.txt.


### Файл добавлен в staging area, но после этого изменён

Вы добавили файл в staging area, но перед самым коммитом вспомнили важную мелочь. 

Например, вместо одного восклицательного знака в конце строки Это файл A! нужно поставить три.

Откройте текстовый редактор и добавьте нужные правки. Теперь можно выполнить коммит, но в любой непонятной ситуации сначала стоит вызвать git status. 

Он покажет следующее.

```
# изменили fileA.txt

$ git status

On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
          modified:   fileA.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   fileA.txt

```
Файл попал и в staged (Changes to be committed), и в modified (Changes not staged for commit). 

В staging area находится версия файла с одним восклицательным знаком, а в Changes not staged for commit — уже изменённая версия, с тремя.

Чтобы закоммитить самую свежую версию файла, нужно снова выполнить git add перед коммитом.


# Оформление сообщений к коммитам

## Стили оформления

### Корпоративный

```
$ git commit -m "LGS-239: Дополнить список пасхалок новыми числами"

```

### Conventional Commits


[Conventional Commits](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/#спецификация)

```
git commit -m "feat: добавить подсчёт суммы заказов за неделю"

```

### GitHub-стиль

```
$ git commit -m "Исправить #334, добавить график температуры"

```


# Как исправить коммит


## Подготавливаем репозиторий


Создайте тренировочный репозиторий для отработки команды.


```
$ mkdir ~/dev/commit-amend-fun

$ cd ~/dev/commit-amend-fun

$ git init

# пропустим вывод git init

```

### Дополнить коммит новыми файлами — git commit --amend --no-edit


```
$ touch main.html

$ touch common.css

# дальше отредактировали оба файла

```

В какой-то момент вы забыли о файле common.css и добавили в коммит только main.html.


```
$ git add main.html

$ git commit -m "Добавить главную страницу"

$ git log --oneline

777fec3 Добавить главную страницу

```

Файл common.css так и остался «висеть» в untracked. В этом легко убедиться, если вызвать git status

```
$ git status
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
          common.css

nothing added to commit but untracked files present (use "git add" to track)

```

Дополните последний коммит забытым файлом common.css с помощью опции --amend

```
$ git add common.css # добавили файл common.css в список на коммит как обычно

# но вместо команды commit -m '...'
# будет:

$ git commit --amend --no-edit

$ git log --oneline

8340eb2 Добавить главную страницу

# коммит в истории всё ещё один (но у него новый хеш)ing added to commit but untracked files present (use "git add" to track)

```

С опцией --amend команда commit не создаст новый коммит, а дополнит последний, просто добавив в него файл common.css.

При этом хеш последнего коммита изменится, потому что изменился список файлов в коммите.

Обратите внимание на опцию --no-edit. Она сообщает команде commit, что сообщение коммита нужно оставить как было.

Точно так же можно добавить не новый файл, а дополнительные изменения в уже добавленном в коммит файле.


```
# ещё раз отредактировали main.html

$ git add main.html # добавили в список на коммит

$ git commit --amend --no-edit

```

### Изменить сообщение коммита — git commit --amend -m "Новое сообщение"

Может быть и так, что добавлять новые файлы в коммит не нужно, зато понадобилось изменить сообщение.

Допустим, хочется заменить сообщение Добавить главную страницу на Добавить главную страницу и стили. 

Сделать это можно через commit --amend с флагом -m.

```
$ git commit --amend -m "Добавить главную страницу и стили"

$ git log --oneline

a31fa24 Добавить главную страницу и стили

```

#### Случилось страшное: открылся редактор

Если забыть указать у команды git commit --amend один из флагов (--no-edit или -m), Git предложит отредактировать сообщение коммита вручную. 

Для этого он откроет текстовый редактор, который установлен в системе по умолчанию. 

Чаще всего это либо GNU nano, либо Vim.


### GNU nano


[редактор GNU nano](https://pictures.s3.yandex.net/resources/M2_T6_01_1686139929.png)

Первая строка Добавить главную страницу и стили — это текущее сообщение коммита. 

Если вы хотите изменить сообщение, нужно отредактировать эту строку.

Допустим, решили добавить в конце сообщения восклицательный знак. 

Чтобы сохранить новое сообщение, нужно нажать Ctrl+X, где X значит exit (англ. «выход»).

💡 В надписях вида ^X, ^G и других «шляпка» ^ обозначает кнопку Ctrl. То есть ^X — это то же самое, что и Ctrl+X.

[редактор GNU nano](https://pictures.s3.yandex.net/resources/M2_T6_03_1686139964.png)

После нажатия Ctrl+X nano предложит сохранить файл, для этого нужно нажать Y (от англ. yes).

Затем редактор предложит изменить имя файла, но делать этого не нужно — просто нажмите Enter.

[редактор GNU nano](https://pictures.s3.yandex.net/resources/M2_T6_02_1686139991.png)

После нажатия Enter редактор закроется, а Git изменит сообщение последнего коммита.

💡 Если вы не хотите менять сообщение через редактор, можно выйти из него с помощью Ctrl+X, а затем выбрать N (от англ. no). 

В таком случае редактор закроется, и Git оставит сообщение последнего коммита «как было».


### Vim

[редактор Vim](https://pictures.s3.yandex.net/resources/M2_T6_04_1686140116.png)

Если вы ещё не умеете пользоваться Vim, мы рекомендуем сразу выйти из редактора и использовать флаг -m для указания сообщений коммита. 

Вот как выйти из Vim:

* Нажмите клавишу Esc.

* Наберите последовательность символов :qa!.

* Нажмите Enter.

[редактор Vim](https://pictures.s3.yandex.net/resources/M2_T6_05_1686140138.png)

После нажатия Enter редактор должен закрыться, а вы сможете продолжить работу так, как будто ничего и не открывалось.

Для запуска учебника на русском языке достаточно выполнить команду vimtutor ru. Без ru запустится английская версия.



# Как откатиться назад, если «всё сломалось»


## Выполнить unstage изменений — git restore --staged <file>

Допустим, вы создали или изменили какой-то файл и добавили его в список «на коммит» (staging area) с помощью git add, 

но потом передумали включать его туда. Убрать файл из staging поможет команда git restore --staged <file> (от англ. restore — «восстановить»).


💡 В выводе команды git status есть подсказка в скобках: use "git restore --staged <file>..." to unstage. 

Так что, даже если вы и забыли эту команду, Git напомнит вам.


В терминале это будет выглядеть примерно так.


```
$ touch example.txt # создали ненужный файл

$ git add example.txt # добавили его в staged

$ git status # проверили статус

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   example.txt

$ git restore --staged example.txt
$ git status # проверили статус

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        example.txt

no changes added to commit (use "git add" and/or "git commit -a")

# файл example.txt из staged вернулся обратно в untracked

```
Вызов git restore --staged example.txt перевёл example.txt из staged обратно в untracked.

Чтобы «сбросить» все файлы из staged обратно в untracked/modified, 

можно воспользоваться командой git restore --staged . : она сбросит всю текущую папку **(.)**.


_💡 Раньше для этой операции использовали команду git reset HEAD._

_Но git reset «перегруженная»: она умеет делать много разных действий в зависимости от переданных параметров._

_Чтобы было меньше путаницы, в Git была добавлена отдельная команда git restore._


## Откатить» коммит — git reset --hard <commit hash>

Иногда нужно «откатить» то, что уже было закоммичено, то есть вернуть состояние репозитория к более раннему.

Для этого используют команду ```git reset --hard <commit hash> ```(от англ. reset  — «сброс», «обнуление» и hard — «суровый»).


```
$ git log --oneline # хеш можно найти в истории

7b972f5 (HEAD -> master) style: добавить комментарии, расставить отступы

b576d89 feat: добавить массив Expenses и цикл для добавления трат # вот сюда и вернёмся

4b58962 refactor: разделить analyzeExpenses() на countSum() и saveExpenses()



$ git reset --hard b576d89

# теперь мы на этом коммите

HEAD is now at b576d89 feat: добавить массив Expenses и цикл для добавления трат

```

Теперь коммит b576d89 стал последним: вся дальнейшая разработка будет вестись от него. 

Файл также вернулся к тому состоянию, в котором был в момент этого коммита. 

А коммит 7b972f5 Git просто удалил. 

Это можно проверить, снова запросив лог. Он покажет следующее.


```
$ git log --oneline

b576d89 (HEAD -> master) feat: добавить массив Expenses и цикл для добавления трат

4b58962 refactor: разделить analyzeExpenses() на countSum() и saveExpenses()

```

Вот так схематично выглядит весь процесс «отката» с помощью git reset --hard <hash>.

[процесс «отката»](https://pictures.s3.yandex.net/resources/M2_T6_1686651127.png)

Будьте осторожны с командой ```git reset --hard```! При удалении коммитов можно потерять что-то нужное.


## «Откатить» изменения, которые не попали ни в staging, ни в коммит, — git restore <file>


Может быть так, что вы случайно изменили файл, который не планировали. 

Теперь он отображается в Changes not staged for commit (modified). 

Чтобы вернуть всё «как было», можно выполнить команду git restore <file>.

```
# случайно изменили файл example.txt

$ git status

On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   example.txt

$ git restore example.txt

$ git status

On branch main
nothing to commit, working tree clean

```

Изменения в файле «откатятся» до последней версии, которая была сохранена через git commit или git add.
