# Навигация в командной строке

## Сменить директорию — cd

```
$ pwd
/projects # где сейчас мы здесь

$ cd github # переходим в папку github

$ cd github/open-source-project # переходим через несколько директорий

$ cd .. # переходим на уровень выше

$ cd . # переходим в текущую директорию

```

## Дополнительные возможности ls

```
$ ls # вывели список файлов
file.txt
photo.png

$ ls -a # вывели список, в котором отображаются скрытые файлы ., .. и .git
.
..
.git
file.txt
photo.png 

```

## Создание файлов и директорий — touch, mkdir

```
$ touch my-new-file.txt # создали файл my-new-file.txt 

$ mkdir new-dir # создали директорию new-dir 

$ mkdir -p dir1/dir-inside/dir-deeper-inside # создали папку dir-deeper-inside в папке dir-inside, которая находится в папке dir1

```

## Копирование файлов — cp

```
$ cp что_копируем куда_копируем
$ cp index.html src/ # скопировали index.html в папку src 

$ cp что_копируем что_копируем что_копируем куда_копируем
$ cp index.html style.css script.js src/ # скопировали три файла (index.html, style.css и script.js) в папку src

```

## Перемещение файлов и папок — mv

```
$ mv table.csv ./very-important-files # сначала указываем имя файла, который хотим переместить, потом путь — куда перемещаем 

$ cd very-important-files
$ ls
table.csv 
# перешли в папку very-important-files и проверили, что всё сработало

```

## Чтение файлов — cat

```
$ cat myfile.txt # распечатали содержимое файла myfile.txt
file-content-1
file-content-2

```

## Удаление файлов и папок — rm, rmdir, rm -r

```
$ rm example.txt # удалили файл example.txt из текущей папки

$ rmdir images # команда удалит папку images из текущей директории, 
               # если папка images пуста

$ rm -r images # удалили папку images со всем её содержимым из текущей директории

```

# Шпаргалка. Базовые команды в консоли

## Навигация

**pwd** _(от англ. print working directory, «показать рабочую папку») — покажи, в какой я папке;_


**ls** _(от англ. list directory contents, «отобразить содержимое директории») — покажи файлы и папки в текущей папке;_


**ls -a** _— покажи также скрытые файлы и папки, названия которых начинаются с символа .;_


**cd first-project** _(от англ. change directory, «сменить директорию») — перейди в папку first-project;_


**cd first-project/html** _— перейди в папку html, которая находится в папке first-project;_


**cd ..** — _перейди на уровень выше, в родительскую папку;_


**cd ~** — _перейди в домашнюю директорию (/Users/Username);_


**cd /** — _перейди в корневую директорию._




## Работа с файлами и папками

### Создание

**touch index.html** _(англ. touch, «коснуться») — создай файл index.html в текущей папке;_


**touch index.html style.css script.js** _— если нужно создать сразу несколько файлов, можно напечатать их имена в одну строку через пробел;_


**mkdir second-project** _(от англ. make directory, «создать директорию») — создай папку с именем second-project в текущей папке._




### Копирование и перемещение

**cp file.txt ~/my-dir** _(от англ. copy, «копировать») — скопируй файл в другое место;_

**mv file.txt ~/my-dir** _(от англ. move, «переместить») — перемести файл или папку в другое место._



### Чтение

**rm about.html** _(от англ. remove, «удалить») — удали файл about.html;_

**rmdir images** _(от англ. remove directory, «удалить директорию») — удали папку images;_

**rm -r second-project** _(от англ. remove, «удалить» + recursive, «рекурсивный») — удали папку second-project и всё, что она содержит._



### Полезные возможности

_Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (&&)._

_У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (↑) и вниз (↓)._

_Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать Tab. Если файл или папка есть в текущей директории, командная строка допишет путь сама._

_Например, вы находитесь в папке dev. Начните вводить cd first и дважды нажмите Tab. Если папка first-project есть внутри dev, командная строка автоматически подставит её имя. Останется только нажать Enter._

## Примеры 

```
$ mkdir second-project && cd second-project && touch index.html style.css 
# создаём папку second-project,
# переходим в папку second-project
# и создаём в ней два файла: index.html и style.css

$ cd /Users/ # перешли в папку Users

$ cd U[Tab] # ввели первую букву имени пользователя и нажали Tab # имя папки Username подставиться автоматически

$ pwd # теперь проверим, где мы сейчас находимся 
/Users/Username # мы в папке Username!

```

# Git

## Установка Git

```
$ git version

/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

$ brew install git

```

## Настройка Git

```
$ git config --global user.name "User Namovich" # имя или ник нужно написать латиницей и в кавычках

$ git config --global user.email username@yandex.ru # здесь нужно указать свой настоящий email

$ cat ~/.gitconfig

$ git config --list

```

## Сделать папку репозиторием — git init

```
$ cd ~/dev/first-project # перешли в нужную папку

$ git init # создали репозиторий

```

## «Разгитить» папку, если что-то пошло не так, — rm -rf .git

```
$ cd <папка с репозиторием> # перешли в папку

$ rm -rf .git # удалили подпапку .git

```

## Подготовить файлы к сохранению — git add

```
$ touch todo.txt

$ touch readme.txt # создали файлы todo.txt и readme.txt

$ git status # проверили статус

$ git add --all # подготовили к сохранению все файлы в репозитории

$ git status # проверили статус

$ git add . # добавить всю текущую папку

$ git status

```

## Выполнить коммит — git commit

```
$ git commit -m 'Мой первый коммит!'

$ git log

$ git log --oneline # краткая информация  

```

# GitHub

## Проверка наличия SSH-ключа

```
$ cd ~ # перешли в домашнюю директорию

$ ls -la .ssh/ # вывели список созданных ключей

```

## Инструкция по генерации SSH-ключа

```
$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"

> Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи
> Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]

$ ls -a ~/.ssh

```

## Инструкция по связыванию SSH-ключа и GitHub-аккаунта

```
# скопировать содержимое ключа в буфер обмена:

$ pbcopy < ~/.ssh/id_rsa.pub

# для ed25519:

$ pbcopy < ~/.ssh/id_ed25519.pub

```

_Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта._

_В меню слева нажмите на пункт SSH and GPG keys._

_В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»)._

_В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»)._

_В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»)._

_В поле Key скопируйте ваш ключ из буфера обмена._

_Нажмите на кнопку Add SSH key (англ. «добавить SSH-ключ»)._



```
$ ssh -T git@github.com # Проверьте правильность ключа с помощью следующей команды.

```

## Привязать удалённый репозиторий к локальному — git remote add

```
$ cd ~/dev/first-project

$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git

```

## Убедиться, что репозитории связаны, — git remote -v

```
$ git remote -v

origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)

```

## Отправить изменения на удалённый репозиторий — git push

```
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте 
                          # заменить main на master.

$ git push

```


## Файл README.md

### Заголовки разных уровней создают решётками.

# H1 — заголовок первого уровня, самый большой
## H2 — заголовок второго уровня, поменьше
### H3
#### H4
##### H5
###### H6 — заголовок шестого уровня, самый маленький

```
# H1 — заголовок первого уровня, самый большой
## H2 — заголовок второго уровня, поменьше
### H3
#### H4
##### H5
###### H6 — заголовок шестого уровня, самый маленький

#### Заголовок 4

```


### Можно добавить черту под заголовком или абзацем.

Текст над чертой

---

Текст под чертой

```
Текст над чертой

---

Текст под чертой

```


### Чтобы сделать разрыв строки, нужно поставить два пробела (в примере ниже они обозначены точками ⋅⋅) или сочетание символов <br>.


Текст до переноса⋅⋅  
Текст после переноса <br>
Текст после второго переноса

```
Текст до переноса⋅⋅  
Текст после переноса <br>
Текст после второго переноса

```

### Чтобы начать новый параграф, в конце предыдущей строки должно стоять два символа переноса. Для этого нужно нажать Enter два раза.

line

another line  


```
line

another line  

```

## Выделение текста

### Чтобы выделить текст курсивом (*текст*), его заключают в звёздочки (астериски) или нижние подчёркивания.

Курсив — это *звёздочки* или _подчёркивания_. 

```
Курсив — это *звёздочки* или _подчёркивания_. 

```

### Чтобы выделить текст полужирным шрифтом (**текст**), его окружают двойными звёздочками или двойными нижними подчёркиваниями.

Полужирный шрифт — двойные **звёздочки** или двойные __подчёркивания__.

Можно совместить выделение **звёздочки и _подчёркивания_**. 

```
Полужирный шрифт — двойные **звёздочки** или двойные __подчёркивания__.

Можно совместить выделение **звёздочки и _подчёркивания_**. 

```

### Чтобы зачеркнуть текст (~~текст~~), его окружают двойными волнистыми линиями — тильдами.

~~Зачёркнутый текст.~~

```
~~Зачёркнутый текст.~~

```

## Списки

### Для оформления нумерованного списка достаточно поставить в начало строки цифры с точкой.

1. Первый пункт нумерованного списка.

2. Второй пункт.

```
1. Первый пункт нумерованного списка.

2. Второй пункт.

```

### Ненумерованный список создаётся звёздочкой с пробелом в начале строки либо дефисом с пробелом.

* первый пункт ненумерованного списка;

* второй пункт ненумерованного списка


- первый пункт ненумерованного списка;

- второй пункт ненумерованного списка 

```
* первый пункт ненумерованного списка;
* второй пункт ненумерованного списка

- первый пункт ненумерованного списка;
- второй пункт ненумерованного списка 

```

## Ссылки

### Чтобы сделать ссылкой часть текста, его заключают в квадратные скобки, а затем указывают нужный адрес в круглых скобках.

[Яндекс](https://www.yandex.ru) 

```
[Яндекс](https://www.yandex.ru) 

```

### Также можно добавить ссылке тайтл (от англ title — «название», «заголовок»). Тайтл — это всплывающая подсказка, которая появляется при наведении мыши на ссылку. Тайтл нужно заключить в кавычки и указать внутри скобок после адреса.

[Яндекс](https://www.yandex.ru "Я Yandex!") 

```
[Яндекс](https://www.yandex.ru "Я Yandex!") 

```

## Код

### Чтобы оформить текст как код, нужно окружить его тройками косых кавычек — грависов. После первой тройки грависов указывают язык программирования, на котором написан код. В маркдауне есть поддержка синтаксиса почти всех популярных языков и инструментов.

```bash
ls - la
```
```html
<h1>А я просто текст</h1>
``` 

## Пример файла README.md

# Шпаргалка markdown

## Выделение текста

Вы можете выделять текст в markdown с помощью символов `_` или `*`. Например:

Пример _курсива_ и **жирного** текста.

## Заголовки

Заголовки можно создавать с помощью символа `#`. Чем больше `#`, тем меньше заголовок. Например:

# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня

## Выделение кода

Чтобы выделить текст как код, поместите его в тройные кавычки `````. 

```
mkdir my_project
cd my_project
git init
```
Это лишь некоторые функции markdown. 

## GitHub-стиль

_GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта._

_Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё._ 

_Для этого в любом месте сообщения нужно указать #<номер задачи>. Например, вот так._


```
$ git commit -m "Исправить #334, добавить график температуры"

```

# Исследуем лог

## Элементы описания коммита

```
$ git log

```

[результат выполнения команды](https://pictures.s3.yandex.net/resources/M2_T5_02_1685969923.png)

## Получить сокращённый лог — git log --oneline

```
$ git log --oneline

```

[результат выполнения команды](https://pictures.s3.yandex.net/resources/M2_T5_03_1685970110.png)


# HEAD — всему голова

[взгляни на HEAD](https://pictures.s3.yandex.net/resources/M2_T5_01_1685972979.png)

## Файл HEAD

```
$ pwd # посмотрели, где мы /Users/user/dev/first-project

$ cd .git/

$ ls # посмотрели, какие есть файлы

COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
HEAD            config     hooks/       info/  objects/

$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/master # в файле вот такая ссылка

```

_Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки)._

_Если заглянуть в этот файл, можно увидеть хеш последнего коммита._


```
$ cat refs/heads/master # взяли ссылку из файла HEAD внутри хеш e007f5035f113f9abca78fe2149c593959da5eb7

$ git log # сверяем с хешем последнего коммита commit e007f5035f113f9abca78fe2149c593959da5eb7

Author: John Doe <johndoe@example.com>

Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел

... # другие коммиты

```

_Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита._

_Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master._

_При работе с Git указатель HEAD используется довольно часто._ 

_Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита._

_Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит._


# Статусы файлов в Git

## Статусы untracked/tracked, staged и modified


* **untracked (англ. «неотслеживаемый»)**
 
_Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые._

_Git «видит», что такой файл существует, но не следит за изменениями в нём._

_У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add._


* **staged (англ. «подготовленный»)**

_После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит._

_В этот момент файл находится в состоянии staged._


* **tracked (англ. «отслеживаемый»)**

_Состояние tracked — это противоположность untracked._

_Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add._

_То есть все файлы, в которых Git так или иначе отслеживает изменения._


* **modified (англ. «изменённый»)**

_Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия._

_Например, файл был закоммичен и после этого изменён._


## Про staged и modified

_Команда git add добавляет в staging area только текущее содержимое файла._

_Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging._

_Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging._

_Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз._


## Типичный жизненный цикл файла в Git

[жизненный цикл файла](https://pictures.s3.yandex.net/resources/M2_T5_1686651284.png)

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.

2. Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked). 

	* Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked). _Обратите внимание: staged и modified у одного файла, но у разных его версий._

	* Ещё раз выполнили git add. Состояние: staged (+ tracked).

3. Сделали коммит с помощью git commit. Состояние: tracked.

4. Изменили файл. Состояние: modified (+ tracked).

5. Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).

6. Сделали коммит. Состояния: tracked.

7. Повторили пункты 4−7 много-много раз.


# Как читать git status


## Какие состояния показывает git status

В итоге git status показывает только следующие состояния файлов:

* **staged** _(Changes to be committed в выводе git status);_

* **modified** _(Changes not staged for commit);_

* **untracked** _(Untracked files)._

## Подготавливаем репозиторий


```
$ cd ~/dev

$ mkdir git-status-lesson

$ cd git-status-lesson

$ git init # тут Git выведет что-нибудь, но мы это пропустим

$ touch README.md

$ git add README.md

$ git commit -m 'Добавить README' # по традиции первым создадим и закоммитим файл README.md

```

## Типичные варианты вывода git status

### Нет ни staged-, ни modified-, ни untracked-файлов.

```
$ git status

On branch master
nothing to commit, working tree clean 

```

### Найдены неотслеживаемые файлы.

```
$ git status

$ touch fileA.txt

$ git status

On branch master
Untracked files: # найдены неотслеживаемые файлы
  (use "git add <file>..." to include in what will be committed)
        fileA.txt

nothing added to commit but untracked files present (use "git add" to track)

```

```
$ git add fileA.txt 

$ git status

On branch master
Changes to be committed: # новая секция
  (use "git restore --staged <file>..." to unstage)
        new file:   fileA.txt

```

```
$ git commit -m 'Добавить файл fileA.txt' # тут будет вывод комманды commit, он нас не интересует

$ git status

On branch master
nothing to commit, working tree clean

```

### Найдены изменения, которые не войдут в коммит

```
# внесли в fileA.txt правки # запросили статус

$ git status 

On branch master
Changes not staged for commit: # ещё одна секция
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   fileA.txt

```

```
$ git add fileA.txt

$ git status

On branch master
Changes to be committed: # все изменения готовы к коммиту
  (use "git restore --staged <file>..." to unstage)
        modified:   fileA.txt

```

### Файл добавлен в staging area, но после этого изменён

```
# изменили fileA.txt

$ git status

On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
          modified:   fileA.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   fileA.txt

```

